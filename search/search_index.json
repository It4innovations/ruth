{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ruth","text":"<p>Ruth is a deterministic traffic simulator designed to simulate traffic flow within the cities. With the simulator we aim to optimize the entire traffic flow within a city instead of optimizing routes for particular drivers. For this purpose the simulator contains several routing algoritms including our in-house Probabilistic Time Dependent Routing (PTDR). Its main component is an estimator of of delay on a route at departure time, called probable delay. It can be seen as kind of forecast what happens on route in future.</p> <p>Computation of probable delay is based on Monte Carlo simulation. A crucial input for this step is having access to probabality profiles of level of service on route segments. These can be computed based on either historical data or the result of simulation as it produces the same output, i.e. Floating Car Data (FCD).</p>"},{"location":"#use-cases","title":"Use cases","text":"<ul> <li> <p>urban planers, i.e., what-if analysis</p> </li> <li> <p>data booster for AI training data</p> </li> </ul>"},{"location":"#references","title":"References","text":"<p>TODO:</p>"},{"location":"data_preparation/","title":"Data preparation","text":"<p>In order to run the simulator we need to prepare two crucial input files:</p> <ol> <li>Origin-destination matrix</li> <li>probability profiles</li> </ol>"},{"location":"data_preparation/#preparation-of-od-matrix-as-input-of-the-traffic-simulator","title":"Preparation of O/D matrix as input of the traffic simulator","text":"<p>To prepare Origin-destination matrix as an input of traffic simulator is two steps process. Firstly, the O/D matrix from traffic flow description is generated. Then the O/D matrix is \"initialized\", i.e., the GPS points are attached to route segments in map, and the initial shortest path for each record is computed.</p>"},{"location":"data_preparation/#generating-od-matrix","title":"Generating O/D matrix","text":"<p>The first input of the traffic simulator is an Origin-destination matrix. To generate it we need a description of traffic flow. This file is provided by Radek Furm\u00e1nek or for testing purposes it might be generated as well.</p> <p>The traffic flow is stored in form of CSV with the following columns:   - <code>start_time</code>: a window start time   - <code>end_time</code>: a window end time   - <code>count_devices</code>: a number of devices going from the origin rectangle to destination one.   - <code>geom_rectangle_from</code>: geometry of origin rectangle   - <code>geom_rectangle_to</code>: geometry of destination rectangle</p> <p>The flow is defined by transitions between areas of predefined size (<code>rectangle_from</code>, <code>rectangle_to</code>). From the flow we just know that there is a specific amount of \"devices\"/vehicles (<code>count_devices</code>) which go from one rectangle to another at specific time range defined by <code>start_time</code> and <code>end_time</code>. Importantly, the <code>end_time</code> is not the time  when the vehicle reaches the destination rectangle, but the end of the time window in which the vehicle departs!</p>"},{"location":"data_preparation/#tool","title":"Tool","text":"<p>To perform this task <code>ruth</code> provides tool: <code>ruth-traffic-flow-to-od-matrix</code>. For testing purposes you can use files in <code>ruth/benchmark/hello-world</code> folder.</p> <pre><code>ruth-traffic-flow-to-od-matrix traffic-flow.csv --out od-matrix.csv\n</code></pre>"},{"location":"data_preparation/#output-description","title":"Output description","text":"<p>The tool randomly generate GPS points with departure times based on the information withing the traffic flow. As the tool uses random generator to spread points in from/to rectangles and time ranges. The tool also provides information about the border which is an extended convex hull of all generated points. Based on this border is later downloaded a map layer from OSM.</p> <p>NOTE: currently all records contains the same border. But in the future if distribution of map layers will be considered each record can have its own border.</p>"},{"location":"data_preparation/#preprocess-traffic-simulator-input-from-od-matrix","title":"Preprocess traffic simulator input from O/D matrix","text":"<p>The second step is preprocessing of the O/D matrix to the simulator's input. The input is serialized version of <code>pandas.DataFrame</code> object. This actually represents a state of all the vehicles. </p> <p>The preprocessing stage consists of three steps:</p> <ol> <li>initialization of <code>Vehicle</code>s state,</li> <li>attach GPS positions to map segments, i.e., transform latitude and longitude of origin and destination GPS points to origin and destination nodes,</li> <li>compute initial shortest path between <code>origin</code> and <code>destinaion</code> nodes.</li> </ol> <p>The second and third steps are performance demanding and the preprocessing tool is prepared for it. It offers thread based parallelization. The task is embarrassingly parallel, hence use as much resources as you can. The argument that enables this is <code>--nproc</code>; the default is 1.</p>"},{"location":"data_preparation/#tool_1","title":"Tool","text":"<p>To perform the preprocessing step <code>ruth</code> provides tool: <code>ruth-od-matrix-to-simulator-input</code>. As the input use a file generated in previous step or <code>benchmark/hello-world/od-matrix.csv</code>. Please note, that the files may differ as there is used the random generator in the previous step.</p> <pre><code>ruth-od-matrix-to-simulator-input od-matrix.csv --out vehicles-state.parquet --nproc=8\n</code></pre> <p>The <code>vehicles-state.parquet</code> is the first input of <code>ruth-simulator</code>.</p>"},{"location":"data_preparation/#preparation-of-probability-profile-file","title":"Preparation of probability profile file","text":"<p>There are two possibilities to prepare the probability profile files. The first is to use historical data collected and managed by IT4Innovation. For the information about connection please contact Radek Furm\u00e1nek.</p> <p>The tool providing an intermediate step is called <code>process_time_range_histograms</code>, and it is available in FCDHistoryAnalytics project. This is a library written in Rust providing functionality over historical data and performance demanding parts of Probabilistic Time Dependent Routing (PTDR).</p> <p>Disclaimer: At this point, this approach is not usable in the context of traffic simulator. The simulator uses a Open Street Maps and the date provided by \u0158SD use different segmentation and route segment indexing.</p> <p>To have a simulation result to process we need firstly to run the simulator. <pre><code>ruth-simulator --departure-time=\"2021-06-16 07:00:00\" --k-alternatives=4 --nproc=8 --out=simulation-result.pickle --seed=7 rank-by-prob-delay vehicles-state.parquet 70 500\n</code></pre></p>"},{"location":"data_preparation/#generating-probability-profile-based-on-simulation-result","title":"Generating probability profile based on simulation result.","text":"<p>The second option how to get a probability profile is to use the result of simulation.</p> <p>This a three-step process:</p> <ol> <li> <p>aggregating FCD based on time <pre><code>ruth-aggregate-fcd aggregate-globalview simulation-result.pickle --round-freq-s 15 --out aggregated_fcd.csv\n</code></pre></p> </li> <li> <p>compute time range histograms <pre><code>process_time_range_histograms_from_csv aggregated_fcd.csv \"2021-06-20 23:59\" --out time_range_histograms\n</code></pre> The date time is the end of time window. The probability profile is typically computed for one week, i.e., end of the week in which the simulation was performed. For further setting use <code>--help</code>.</p> </li> <li> <p>generate probability profiles <pre><code>time_range_histograms_to_prob_profiles &lt;TIME_RANGE_HISTOGRAMS&gt;.data\n</code></pre></p> </li> </ol> <p>The second and third tool are from FCDHistoryAnalytics.</p>"},{"location":"installation/","title":"Installation instruction","text":"<p>It is important to note that the simulator is primarly meant to be running on linux machine and for large city simulations computer cluster.</p> <p>Up to the version v1.1 it was also possible to run it on mac smoothly. Nevertheless, this had always been only for developing purposes. Dependencies introduced in v1.1 make it impossible. We provide workaround based on docker which helps to overcome this issue.</p>"},{"location":"installation/#installation","title":"Installation","text":"<pre><code># requirements\nsudo apt-get update &amp;&amp; sudo apt-get install -y --no-install-recommends \\\n    git curl \\\n    build-essential gdal-bin libgdal-dev openmpi-bin libopenmpi-dev \\\n    python3 python3-dev python3-virtualenv python3-pip python3-setuptools python3-wheel\n\n# install rust\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y\n\n# create and activate python virtual environment\nvirtualenv venv\nsource venv/bin/activate\n\n# within the venv\n# install and update python dependencies\npython3 -m pip install -U pip setuptools wheel cython\n\n# install ruth - the traffic simulator\npython3 -m pip install git+https://github.com/It4innovations/ruth.git\n</code></pre>"},{"location":"installation/#test-run","title":"Test run","text":"<ul> <li>activate virtual environment with <code>ruth</code> installed</li> <li>use the files in <code>benchmarks/od-matrix/</code></li> </ul> <pre><code>ruth-simulator --departure-time=\"2021-06-16 07:00:00\" --k-alternatives=4 --nproc=8 --out=simulation_record.pickle --seed=7 rank-by-prob-delay benchmarks/od-matrices/INPUT-od-matrix-10-vehicles-town-resolution.parquet benchmarks/od-matrices/prob-profile-for-2021-06-20T23:59:00+02:00--2021-06-27T23:59:00+02:00.mem 70 500\n</code></pre>"},{"location":"tools/","title":"Available tools","text":"<p>Apart from the simulator itself there is several other tools provided.</p>"},{"location":"tools/#tools-provided-by-ruth","title":"Tools provided by Ruth","text":"<ul> <li><code>ruth-simulator</code> - deterministic traffic simulator</li> <li><code>ruth-traffic-flow-to-od-matrix</code> - generate origin-destination (O/D) matrix from traffic flow description (details in <code>help</code>; the traffic flow file is prepared by Radek Furmanek.)</li> <li><code>ruth-od-matrix-to-simulator-input</code> - generate from O/D matrix the input for the simulator. It may take time, as it pins the GPS positions to map segments. Embarrassingly parallel, the more cores (threads) provided the quicker processing. Ideally let it compute on Karolina node.</li> <li><code>ruth-aggregate-data</code> - aggregate the history records. The aggregated version can be used as an input for generating probability profiles with <code>process-time-range-histograms-from-csv</code> (FCD History Analytics bellow)</li> <li><code>ruth-show-gv</code> - only for debug purposes it shows a map with dots representing the FCD at the particular time slot. Not suitable for huge history records; only for debug. It might be used as an inspiration how to look at the data.</li> <li><code>ruth-split-segment-id</code> - obsolete! It was used to prepare data for flow map visualisation (Pavlina Smolkova &amp; Sofia Michailidu).</li> <li><code>ruth-data-preprocessing</code> - obsolete! the original input data preparation; not valid anymore.</li> </ul>"},{"location":"tools/#tools-provided-by-fcdhistoryanalytics-component-rust","title":"Tools provided by FCDHistoryAnalytics component (Rust)","text":"<ul> <li> <p>https://code.it4i.cz/everest-internal/fcdhistoryanalytics (public access token: [[https://project_1113_bot:v4GzuGgiqjycBqCAy4ms@code.it4i.cz/everest/fcdhistoryanalytics.git]])</p> </li> <li> <p>The idea behind, was to create a toolset with appropriate data structures that is able to process historical FCD data provided by \u0158SD (\u0159editelstv\u00ed silnic a d\u00e1lnic).</p> </li> <li>Project divided into 4 packages:<ul> <li><code>data</code> - responsible for generating Time Range Histograms (TRH) from FCD data. It can connect to IT4I's database or it can be provided with CSV file; CSV file is suitable for generating the TRHs from simulators output.</li> <li><code>datatimebox</code> - data structures related to time and space. Providing functionality over such times, like iterators, hashing, etc.<ul> <li><code>timerange</code> - time range defined by start, end, and step </li> <li><code>timeindex</code> - generic definition of time index and its generator. Simulator then uses so called Group Time Index. It divides a time range into groups and each group is then represented by its index.</li> <li><code>storages/timerangehistogram</code> - a storage which stores a time range histogram for particular time index and space. The space refers to location on map, e.g. routing segment.</li> </ul> </li> <li><code>ptdr</code> - functionalities and data structures related to Probabilistic Time Dependent Routing (PTDR); More precisely there is covered only part of Monte Carlo simulation (a procedure computing probable delay on a route at departure time). The other part is related to so called probability profiles. A probability profile is a simplified view on distribution of level of service (LoS) on route segment in time. The distribution is given by TRH. The TRH is then sampled (in our case to quartiles + 99 percentile) and these samples form one record of probability profile.</li> <li><code>scripts</code> - python script for generating so called Delay Graph (the graph shown in gitlab readme page)</li> </ul> </li> <li>There are other EVEREST related packages:<ul> <li><code>ptdr-cpp</code> - distilled version of Monte Carlo written in C++ and suitable for HW synthesis. The probability profiles are attached to each segment because of FPGA. It is clear that is inefficient but it's just for demo purpose of working FPGA version (up to this point 14.2.2023 still not available). For the future version is expected that probability profiles will be stored in memory \"near to FPGA\" with random access.</li> <li>other scripts in <code>scripts</code> folder</li> </ul> </li> <li>The last folder <code>testing-data</code> contains a basic of data for testing</li> </ul>"},{"location":"tools/#build","title":"Build","text":"<ul> <li>In root directory call <code>cargo build --release</code>. Be careful debug version is much slower.</li> <li>The build tools are located in <code>./target/release</code> folder.</li> </ul>"},{"location":"tools/#workflow","title":"Workflow","text":"<ol> <li>Generate a set of time range histograms for each segment at time index.</li> <li>From the previous step generate probability profiles. Later used in simulator or for Monte Carlo simulation (computation of probable delay on route at departure time).</li> </ol>"},{"location":"tools/#tools","title":"Tools","text":""},{"location":"tools/#data-package","title":"Data package","text":"<ul> <li><code>process_time_range_historgrams</code> - gather the info from database; it is necessary to specify a connection to IT4I's historical data (Contact: Radek Furmanek). Nevertheless, currently useless as the historical data uses different indexing of segments (not connectable to OSM data used by simulator). It will be useful once we have a relation between TMC segments and OSM map network; or we get maps which works with TMC segments - maps provided by CEDA.</li> <li><code>process_time_range_histograms_from_csv</code><ul> <li>example: <code>./target/release/process_time_range_histograms_from_csv ~/projects/everest/ruth-cluster-data/aggregated-fcd-sim.csv \"2021-06-20 23:59\" --out simulator-data</code></li> </ul> </li> <li>Helper tools:<ul> <li><code>joiner</code> - joins two sets of time range histograms into one file</li> <li><code>cmp_histograms</code> - a histogram comparator for debug purposes </li> <li><code>show_histogram</code> - a histogram plotter</li> </ul> </li> </ul>"},{"location":"tools/#ptdr-package","title":"Ptdr package","text":"<ul> <li><code>time_range_histograms_to_probab_profiles</code> sample the distributions of LoS on route segments at time index and produce probability profile file used by the simulator.<ul> <li>example: <code>./target/release/time_range_histograms_to_prob_profiles histograms-for-2021-06-20T23:59:00+02:00--2021-06-27T23:59:00+02:00.data</code></li> </ul> </li> <li><code>probdelay</code> a binary which can compute a probable delay on a route at departure time. It Can also produce these info for range of times, e.g., the entire day with 5min step. This can be then processed with <code>scripts/delay-graph.py</code>. </li> </ul>"},{"location":"work_with_sim_output/","title":"Simulation output","text":"<p>The output of the simulation is a serialized object of <code>ruth.simulator.Simulation</code> type. The resulting object represents a captured state of the simulation from which it can continue; if not finished yet. Apart from the evolution of traffic during the simulation, <code>Simulation</code> contains other useful information and post processing functions, e.g., performance inside, post-processing data in form of <code>pandas.DataFrame</code>, etc.</p>"},{"location":"work_with_sim_output/#read-the-simulation","title":"Read the simulation","text":"<p>To look at the simulation results one can write a Python script or use interactive shell.</p> <pre><code>from ruth.simulator import Simulation\n\nsim = Simulation.load(\"/path/to/sim-result.pickle\")\n</code></pre>"},{"location":"work_with_sim_output/#history","title":"History","text":"<p>The result of simulation is recorded in <code>history</code>. The history can be processed as a `pandas.DataFrame.</p> <pre><code>history_df = sim.history.to_dataframe()\n</code></pre> timestamp segment_id vehicle_id start_offset_m speed_mps segment_length status node_from node_to 0 2021-06-16 07:00:27.331000 OSM31765033T2671968558 3 19.425 8.33333 218.052 not started 31765033 2671968558 1 2021-06-16 07:00:27.820000 OSM265825223T73388626 1 15.1667 8.33333 67.275 not started 265825223 73388626 2 2021-06-16 07:00:30 OSM10288560273T31764596 4 69.4444 13.8889 118.922 not started 10288560273 31764596 <p>A single record in history consists of:</p> <ul> <li><code>timestamp</code> - timestamp of an event,</li> <li><code>segment_id</code> - a unique identifier of route segment,</li> <li><code>vehicle_id</code> - a unique identifier of vehicle,</li> <li><code>start_offset_m</code> - an offset in meters from the beginning of segment (<code>node_from</code>),</li> <li><code>speed_mps</code> - a speed assigned to the vehicle at this point of time in m/s,</li> <li><code>segment_length</code> - a length of the segment,</li> <li><code>node_from</code> - a starting node of the segment,</li> <li><code>node_to</code> - an ending node of the segment,</li> <li><code>status</code> - an arbitrary text used for debugging purposes (\"not started\" is ok status anything else is suspicious).</li> </ul>"},{"location":"work_with_sim_output/#global-view","title":"Global view","text":"<pre><code>gv_df = sim.global_view.to_dataframe()\n</code></pre> <p>The globalview is a subset of history records. The history records are only collected via the simulation and it is an actual result used for further analysis. On the other hand, global view is an active subset of history, i.e., list of records that are used for computation level of service in a near distance (\"a distance driver see directly from window\"; it's a hyperparameter of the simulation). It's not valid for any kind of analysis. The global view can be gained from history by calling <code>drop_old</code> method. All records older then provided threshold are droped.</p>"},{"location":"work_with_sim_output/#performance-insight","title":"Performance insight","text":"<p>During the simulation duration of particular functions is measured. This is stored in <code>step_info</code>, and similarly to <code>history</code> it can be also processed as dataframe.</p> <pre><code>perf_df = sim.step_info_to_dataframe()\n</code></pre> step n_active duration allowed_vehicles alternatives collect vehicle_plans select_plans transform_plans advance_vehicle update compute_offset drop_old_records end_step 0 0 1 2272.18 0.146151 2267.79 0.00524521 0.0038147 3.75414 0.211954 0.157356 0.0331402 0.0119209 0.00405312 0.00190735 1 1 3 3144.36 0.0708103 3137.53 0.0100136 0.00691414 6.30188 0.136137 0.220299 0.0469685 0.0140667 0.00500679 0.0038147 2 2 1 2227.49 0.0720024 2225.63 0.00691414 0.00286102 1.60289 0.0360012 0.0760555 0.0309944 0.0119209 0.00476837 0.00119209 <p>A single record in step info consists of:</p> <ul> <li><code>step</code> - a step number,</li> <li><code>n_active</code> - a number of active vehicles; those which moved in the step,</li> <li><code>duration</code> - an overall duration of the step in milliseconds,</li> <li><code>allowed_vehicles</code> - a duration of filtering which vehicles can move,</li> <li><code>alternatives</code> - a duration of computation alternative routes,</li> <li><code>collect</code> - coleecting vehicles without alternatives and finishing them,</li> <li><code>vehicle_plans</code> - a duration to assemble all possible plans for vehicle,</li> <li><code>select_plans</code> - a duration of process of picking the plan which will be used; here is the Monte Carlo simulation used for estimation of probable delay on a route,</li> <li><code>transform_plans</code> - a plan consist of vehicle and <code>Route</code> used for simulation; it transform the <code>Route</code> to OSM route,</li> <li><code>advance_vehicle</code> - a duration of moving of a vehicle,</li> <li><code>update</code> - update the simulation state,</li> <li><code>compute_offset</code> - compute the next minimal offset for selecting next bunch of active vehicles,</li> <li><code>drop_old_records</code> - a duration of dropping records within global view,</li> <li><code>end_step</code> - a duration of user specific function performed at the end of each step.</li> </ul>"},{"location":"work_with_sim_output/#look-at-caches","title":"Look at caches","text":"<pre><code># find out used caches\nsim.caches\n# defaultdict(&lt;function ruth.simulator.simulation.get_lru_cache()&gt;,\n#           {'alternatives': &lt;pylru.lrucache at 0x16dfcefd0&gt;})\n\ncaches_df = sim.cache_info_to_dataframe('alternatives')\n</code></pre> timestamp n_hits total hit_rate 0 2023-03-23 10:11:39.678220 0 1 0 1 2023-03-23 10:11:41.908312 0 3 0 2 2023-03-23 10:11:45.052772 0 1 0 <p>A single record in cache info consists of:</p> <ul> <li><code>timestamp</code> - a timestamp of event,</li> <li><code>n_hits</code>  - how many times the cache was hit,</li> <li><code>total</code> - a number of vehicles for which the alternatives are computed,</li> <li><code>hit_rate</code> - <code>n_hits</code> / <code>total</code>.</li> </ul>"},{"location":"work_with_sim_output/#simulation-postprocessing","title":"Simulation postprocessing","text":"<p>The records stored in history can be considered as so-called RAW FCD (points in time on map). In order to get aggregated version the simulation can be postprocessed via <code>ruth-aggregate-fcd</code> tools. There are two versions <code>aggregate-globalview</code> and <code>aggregate-globalview-set</code>. The second one can be used to aggregate the results of more than one simulation. By aggregating one simulation results we get a CSV of the following format:</p> <pre><code>ruth-aggregate-fcd aggregate-globalview  --round-freq-s 300 --out aggregated_fcd.csv\n</code></pre> segment_osm_id fcd_time_calc los segment_length 0 OSM236504238T694219 2021-06-16 07:20 0.928181 373.471 1 OSM29745937T29745938 2021-06-16 07:20 0 43.018 2 OSM2506908136T26424525 2021-06-16 07:15 0.00741471 48.714 <p>A single record consists of: * <code>segment_osm_id</code> - an id of OSM segment, * <code>fcd_time_calc</code> - a calculated time based <code>-round-freq-s</code>, * <code>los</code> - level of service on segment * <code>segment_length</code> - length of the segment</p> <p>These data can be used for further analysis. For example, we can define something like traffic jam rate:</p> <pre><code>import pandas as pd\n\ndf = pd.read_csv(\"aggregated_fcd.csv\", sep=';')\n\ntj_rate = len(df[df[\"los\"] &lt; 0.2]) / len(df)\n</code></pre> <p>If the level of service is bellow 20% we can consider it as a traffic jam. The definition of threshold may differ.</p>"},{"location":"docker/usage-with-docker/","title":"Run the simulator within a docker environment","text":"<p>If you are on other system then linux, please use the docker for developing purposes and small (local machine) tests. For this purpose use the follwing Dockerfile.</p> <ol> <li>Clone the simulator repository. This will repository will be used for further development.</li> </ol> <pre><code>git clone https://github.com/It4innovations/ruth.git\n</code></pre> <ol> <li>Build the docker image within the folder with Dockerfile</li> </ol> <pre><code>docker build -t ruth .\n</code></pre> <ol> <li>Run the docker file with mounted volumes</li> </ol> <pre><code>docker run -it -v &lt;/absolute/path/to/host/ruth&gt;:/workdir -v &lt;absolute/path/to/host/datadir&gt;:/data --name ruth-con ruth \n</code></pre> <p>The following commands are performed within the docker container.</p> <ol> <li>Install ruth.</li> </ol> <p><pre><code>python3 -m pip install -e .\n</code></pre> The default folder in running container is <code>/workdir</code>. Which is the same one where ruth from host is mapped. The <code>-e</code> option is important as it allows us to modify the ruth source code on host machine and directly test it within container without re-installation.</p>"}]}